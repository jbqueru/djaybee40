; Copyright 2024 Jean-Baptiste M. "JBQ" "Djaybee" Queru
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU Affero General Public License as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
;
; As an added restriction, if you make the program available for
; third parties to use on hardware you own, such as public gaming
; cabinets (whether or not in a gaming arcade, whether or not
; coin-operated or otherwise for a fee,) the conditions of
; section 13 will apply even if no network is involved.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
; GNU Affero General Public License for more details.
;
; You should have received a copy of the GNU Affero General Public License
; along with this program. If not, see <https://www.gnu.org/licenses/>.
;
; SPDX-License-Identifier: AGPL-3.0-or-later

; Coding style:
;	- ASCII
;	- hard tabs, 8 characters wide, except in ASCII art
;	- 120 columns overall
;	- Standalone block comments in the first 80 columns
;	- Code-related block comments allowed in the last 80 columns
;	- Global symbols for code are CamelCase
;	- Symbols for variables are snake_case
;	- Symbols for hardware registers are ALL_CAPS
;	- Related symbols start with the same prefix (so they sort together)
;	- Include but comment out instructions that help readability but
;		don't do anything (e.g. redundant CLC when the carry is
;		guaranteed already to be clear). The comment symbol should be
;		where the instruction would be, i.e. not on the first column.
;		There should be an explanation in a comment.
;	- Note: rulers at 40, 80 and 120 columns help source width

; #############################################################################
; #############################################################################
; #############################################################################
; ########                                                             ########
; ########                                                             ########
; ########                        DJAYBEE AT 40                        ########
; ########                                                             ########
; ########          CELEBRATING 40 YEARS OF CODING EXPERIENCE          ########
; ########                                                             ########
; ########             A DEMO FOR AMSTRAD CPC 464 TO 6128              ########
; ########                                                             ########
; ########                                                             ########
; #############################################################################
; #############################################################################
; #############################################################################

; At the technical level, the following high-level points are noteworthy:
;
; The display is based around 51x20 CRTC cells, i.e. 408*160, which almost
; fills the horizontal overscan, chosen because it fits in 16kB of framebuffer
; and approximately matches the aspect ration of widescreen movies.
;
; It uses hardware scrolling, with page-flipping between pages that are off
; by half a cell.
;
; It races the beam during the active display, changing one of the colors so
; that sprites can each use a different color, giving the illusion of more
; than 4 simultaneous colors.
;
; It interferes with interrupt timing so that it only needs to race the beam
; during the active part or the display.
;
;	More specifically, the default interrupt timing looks like this, with
;	an interrupt request every 52 lines starting 2 lines after Vsync:
;		Line 002 Interrupt
;		Line 054 Interrupt
;		Line 106 Interrupt
;		Line 158 Interrupt
;		Line 210 Interrupt
;		Line 262 Interrupt
;
;	With the CRTC timings overlaid on top, here's the timing:
;		Line 000 Vsync start
;		Line 002 Interrupt
;		Line 054 Interrupt
;		Line 088 Display start
;		Line 106 Interrupt
;		Line 158 Interrupt
;		Line 210 Interrupt
;		Line 248 Bottom Border start
;		Line 262 Interrupt
;
;	But that doesn't work well to synchronize with the top of the display:
;	Synchronizing at line 54 requires another 34 lines of perfect sync
;	Before reaching the active display.
;
;	Now, the CPC tries to avoid scheduling interrupts too close to one
;	another. If an interrupt gets acknowledged less than 20 lines from
;	the next one (typically because interrupts would be disabled for a
;	long time to allow for some interrupt-free processing), the next one
;	is delayed by 32 lines to give things time to get processed.
;
;	We can abuse that to get the interrupts where we want them: by forcing
;	the first interrupt of the frame to get acknowledged late enough, the
;	subsequent ones get delayed by 32 lines. In other words, if we disable
;	interrupts immediately after Vsync (which we can poll) and keep them
;	disabled for 35 to 53 lines (enough to be more than 32 lines late,
;	but not so much to merge with the next interrupt), the interrupt that's
;	normally scheduled on line 54 will shift to line 86, which is just
;	about perfect for a display that starts on line 88, and the timing
;	now looks like this:
;
;	With the CRTC timings overlaid on top, here's the timing:
;		Line 000 Vsync start
;		Line 002 Interrupt request
;		Line 35-53 (typically 44) Interrupt acknowledge
;		Line 086 Interrupt
;		Line 088 Display start
;		Line 138 Interrupt
;		Line 190 Interrupt
;		Line 242 Interrupt
;		Line 248 Bottom Border start
;		Line 294 Interrupt
;
;	That looks promising, but it doesn't actually work: because the CPC
;	tries to keep interrupts synchronized with the frame, it re-syncs
;	them at Vsync, and it has a different mechanism there to keep
;	interrupts far enough apart: if the previous interrupt was less than
;	32 lines ago, it skips the first interrupt of the frame entirely,
;	and goes back to the regular schedule after that. Our actually timing
;	would look like this:
;		Line 000 Vsync start
;		Line 002 Interrupt request
;		Line 35-53 (typically 44) interrupt acknowledge
;		Line 086 Interrupt
;		Line 088 Display start
;		Line 138 Interrupt
;		Line 190 Interrupt
;		Line 242 Interrupt
;		Line 248 Bottom Border start
;		Line 294 Interrupt
;		Line 000 Vsync start
;		Line 054 Interrupt
;		Line 088 Display start
;		Line 106 Interrupt
;		Line 158 Interrupt
;		Line 210 Interrupt
;		Line 248 Bottom Border start
;		Line 262 Interrupt
;
;	Notice that the second frame has no interrupt at line 2. No interrupt
;	request, no way to delay the interrupt acknowledge, no way to cause
;	the next interrupt to get delayed.
;
;	To compensate for that, we need to introduce some other delay in the
;	interrupt timing: if we add another 32 lines somewhere, the last
;	interrupt of the frame will be on line 274 (210 delayed twice), and
;	Vsync will happen more than 32 lines later, going back to the previous
;	sequence.
;
;	It's possible to use the exact same trick a second time, and there
;	are two possible options for this:
;		Line 000 Vsync start
;		Line 002 Interrupt request
;		Line 35-53 (typically 44) Interrupt acknowledge
;		Line 086 Interrupt
;		Line 088 Display start
;		Line 138 Interrupt request
;		Line 171-189 (typically 180) Interrupt acknowledge
;		Line 222 Interrupt
;		Line 248 Bottom Border start
;		Line 274 Interrupt
;
;	We need to keep running synchronized code for a little while, 92 lines
;	during the display, but for the current use case this isn't an issue
;	since we're running synchronized code anyway. The issue is that we
;	need to handle an interrupt in the middle of the frame, and that eats
;	probably at least 10 us (EI, 5 to trigger the mode 1 interrupt,
;	4 for a minimal RET). 10 us is a whole lot to sacrifice.
;
;	That can be avoided by doing the delay on a later interrupt:
;		Line 000 Vsync start
;		Line 002 Interrupt request
;		Line 35-53 (typically 44) Interrupt acknowledge
;		Line 086 Interrupt
;		Line 088 Display start
;		Line 138 Interrupt request
;		Line 190 Interrupt request
;		Line 242 Interrupt request
;		Line 248 Bottom Border start
;		Line 275-293 Interrupt acknowledge
;
;	That's somewhat pointless: the whole point of shifting interrupts
;	in the first place was to save us 32 lines of perfect-sync code, but
;	that option replaces that with a minimum of 35+27 lines of mostly-sync
;	code, which has a good chance of being just about as constraining.
;
;	However, hidden in the Gate Array's Mode and Rom Enable Register (MRER)
;	lives an extra bit, bit 4, for which documentation is somewhat sparse
;	and unclear. Writing to MRER with that bit set to 1 either clears the
;	top bit or all bits of the interrupt counter, and might also clear any
;	pending interrupt. Such imprecision isn't that great, but there are
;	times when that doesn't matter much: if we touch that bit at a time
;	when the line counter is slightly greater than 32, and at a time when
;	it doesn't matter whether a scheduled interrupt might get canceled,
;	the differences in interpretation might not matter. The timing might
;	now look like this:
;		Line 000 Vsync start
;		Line 002 Interrupt request
;		Line 35-53 (typically 44) Interrupt acknowledge
;		Line 086 Interrupt
;		Line 088 Display start
;		Line 138 Interrupt request
;		Line 171 MRER bit 4
;		Line 222/223 Interrupt request
;		Line 248 Bottom Border start
;		Line 249 Interrupt acknowledge
;		Line 274/275 Interrupt
;
;	The same approach can be done at line 223 instead of 171, i.e. one
;	interrupt later.
;
;	At first glance, that doesn't save us much from having to run
;	an interrupt in the middle of the frame, and it might even be worse:
;	we'd need to save BC, load it with the appropriate value, write to the
;	Gate Array, and restore it, which looks like 14 NOPs, with the
;	advantage that we can probably scatter that code a bit across any
;	region that doesn't otherwise touch BC. However, since the code that
;	we're running probably has B already pointed to the right location,
;	and since it probably has some times when one of the other registers
;	is unused, loading a byte into a register and writing it to the Gate
;	Array only costs 6 NOPs. Pushing that reasoning further, if any of the
;	synchronous code reads color data from a table, we simply need to
;	design the screen such that one of the colors doesn't need to be changed
;	on line 171 (or 223) and insert the MRER value in that table instead,
;	at which point this approach costs us no code complexity or timing
;	difficulties, replacing them with a bit of design difficulty.
;
;	Nothing can be perfect, we're left with 3 options:
;	-Natural option, keep interrupts as original, and race the beam for
;		32 additional lines. That might be useful to display some
;		rasters.
;	-Interrupt delay, run two chunks of semi-synchronous code, overall
;		44 +/-9 lines and 36 +/- 9 lines.
;	-Interrupt delar + MRER, run one chunk of semi-synchonous code instead
;		of two, but have the design constraint that some colors need
;		to be read from a table where one entry at a mostly fixed
;		location won't contain actual color data.

	.z80
	.org	$4000

; #############################################################################
; #############################################################################
; ###                                                                       ###
; ###                                                                       ###
; ###                       CPC Hardware Definitions                        ###
; ###                                                                       ###
; ###                                                                       ###
; #############################################################################
; #############################################################################

; TODO!!!

; #############################################################################
; #############################################################################
; ###                                                                       ###
; ###                                                                       ###
; ###                        Hardware Initialization                        ###
; ###                                                                       ###
; ###                                                                       ###
; #############################################################################
; #############################################################################

InitHW:
; *** First, disable interrupts, so that the firmware is out of the way ***
	DI

; *** Get stack set up in lower 48kB ***
	LD	SP,$C000

; *** Disable ROMs, switch to mode 1 ***
	LD	BC,$7F00 + 10001101b
	OUT	(C),C

; *** Disable 6128 extended RAM ***
	LD	C,11000000b
	OUT	(C),C

; *** Black palette ***
	LD	DE,(00000000b << 8) + 01000000b + $14
	OUT	(C),D
	OUT	(C),E
	INC	D
	OUT	(C),D
	OUT	(C),E
	INC	D
	OUT	(C),D
	OUT	(C),E
	INC	D
	OUT	(C),D
	OUT	(C),E
	LD	D,00010000b
	OUT	(C),D
	OUT	(C),E

; *** Program CRTC 384 x 160 (cinemascope) ***
	LD	BC,($BC << 8) + 0
	OUT	(C),C
	LD	BC,($BD << 8) + 63
	OUT	(C),C
	LD	BC,($BC << 8) + 1
	OUT	(C),C
	LD	BC,($BD << 8) + 51
	OUT	(C),C
	LD	BC,($BC << 8) + 2
	OUT	(C),C
	LD	BC,($BD << 8) + 51	; use 51 or 52
	OUT	(C),C
	LD	BC,($BC << 8) + 3
	OUT	(C),C
	LD	BC,($BD << 8) + $8B
	OUT	(C),C
	LD	BC,($BC << 8) + 4
	OUT	(C),C
	LD	BC,($BD << 8) + 38
	OUT	(C),C
	LD	BC,($BC << 8) + 5
	OUT	(C),C
	LD	BC,($BD << 8) + 0
	OUT	(C),C
	LD	BC,($BC << 8) + 6
	OUT	(C),C
	LD	BC,($BD << 8) + 20
	OUT	(C),C
	LD	BC,($BC << 8) + 7
	OUT	(C),C
	LD	BC,($BD << 8) + 28
	OUT	(C),C
	LD	BC,($BC << 8) + 8
	OUT	(C),C
	LD	BC,($BD << 8) + 00b
	OUT	(C),C
	LD	BC,($BC << 8) + 9
	OUT	(C),C
	LD	BC,($BD << 8) + 7
	OUT	(C),C
	LD	BC,($BC << 8) + 12
	OUT	(C),C
	LD	BC,($BD << 8) + $30
	OUT	(C),C
	LD	BC,($BC << 8) + 13
	OUT	(C),C
	LD	BC,($BD << 8) + $00
	OUT	(C),C


; *** Set 8255 to default mode (register A as write) ***
	LD	BC,($F7 << 8) + 10000010b

; *** Basic AY-3-8912 setup - mixer off ***
	LD	BC,($F4 << 8) + 7
	OUT	(C),C
	LD	BC,$F6C0
	OUT	(C),C
	LD	BC,$F600
	OUT	(C),C
	LD	BC,($F4 << 8) + 0
	OUT	(C),C
	LD	BC,$F680
	OUT	(C),C
	LD	BC,$F600
	OUT	(C),C

; *** Turn floppy motors off ***
	LD	BC,$FA7E
	XOR	A
	OUT	(C),A

; *** Move code to execution location ***
	LD	DE,InitDemo
	LD	HL,EndDemo
	;CP	A		; clear carry
	SBC	HL,DE
        LD	B,H
        LD	C,L
	LD	HL,CopyStart
	LD	DE,InitDemo
	LDIR
	JP	InitDemo

; #############################################################################
; #############################################################################
; ###                                                                       ###
; ###                                                                       ###
; ###                        Software Initialization                        ###
; ###                                                                       ###
; ###                                                                       ###
; #############################################################################
; #############################################################################

CopyStart:
	.phase	$40
InitDemo:

; TODO: clear all RAM.

; *** Set our own interrupt routine ***
;	LD	A,$C3		; C3 = unconditional jump
;	LD	($38),A
;	LD	HL,Interrupt
;	LD	($39),HL

	LD	HL,$C9FB	; FB = EI, C9 = RET, little-endian
	LD	($38),HL

	IM	1

; *** Clear framebuffer ***
	LD	HL,$C000
	LD	A,L
ClearFBLoop:
	LD	(HL),A
	INC	HL
	CMP	H
	JR	NZ, ClearFBLoop

; *** Set up proper palette ***
	LD	BC,$7F01
	OUT	(C),C
	LD	C,$40
	OUT	(C),C
	LD	C,$02
	OUT	(C),C
	LD	C,$4B
	OUT	(C),C

; *** All done, enable interrupts ***
	EI

; #############################################################################
; #############################################################################
; ###                                                                       ###
; ###                                                                       ###
; ###                               Main Loop                               ###
; ###                                                                       ###
; ###                                                                       ###
; #############################################################################
; #############################################################################


Loop:
; *** Wait for the VSYNC bit to be asserted ***
WaitVBL:
	LD	B,$F5
	IN	A,(C)
	RRCA
	JR	NC,WaitVBL

; *** Shift interrupts ***
	DI

	LD	HL,(0)
	INC	HL
	LD	A,00000011b
	AND	H
	OR	00110000b
	LD	H,A
	LD	(0),HL

	LD	BC,($BC << 8) + 12
	OUT	(C),C
	INC	B
	OUT	(C),H
	LD	BC,($BC << 8) + 13
	OUT	(C),C
	INC	B
	OUT	(C),L


; Wait between 35 and 53 lines, and enable interrupts
	LD	B,224		; 35 lines is 2240 NOPs
				; run a 10-NOP loop 224 times
Skip35:
	ADD	HL,HL		; 3
	ADD	HL,HL		; 3
	DJNZ	Skip35		; 4

	EI
	NOP			; Delay to avoid EI/HALT pair

; -------------------------------
; Start line 86 (Border 78)	;
;				;
; Sync up with the display and will remain in sync all the way
				;
	HALT			; +16/16 (HSync + request + EI/RET)
				;
	LD	B,11		; +2/18
L86Wait:			;
	DJNZ	L86Wait		;	10*4+3=43
				; +43/61 loop
	ADD	HL,HL		; +3/64 (filler)
				;
; End line 86 (Border 78)	;
; -------------------------------

; -------------------------------
; Start line 87 (Border 79)	;
				;
	LD	B,13		; +2/2
L87Wait:			;
	DJNZ	L87Wait		;	12*4+3=51
				; +51/53 loop
	INC	BC		; +2/55 (filler)
				;
	LD	BC,$7F10	; +3/58
	OUT	(C),C		; +4/62
	LD	C,$4B		; +2/64
				;
; End line 87 (Border 79)	;
; -------------------------------

	OUT	(C),C		; +4

	DI


	LD	E,137
XLp3:

	LD	B,14	; 2
Xlp4:
	DJNZ	Xlp4	; 13*4+3
	NOP		; 1
	NOP		; 1
	NOP		; 1
	DEC	E	; 1
	JR	NZ,Xlp3 ; 3

; *** Poke MREM bit 4 ***
	LD	BC,$7F00 + 10011101b
	OUT	(C),C

	LD	E,25
XLp5:

	LD	B,14	; 2
Xlp6:
	DJNZ	Xlp6	; 13*4+3
	NOP		; 1
	NOP		; 1
	NOP		; 1
	DEC	E	; 1
	JR	NZ,Xlp5 ; 3

	LD	BC,$7F10
	OUT	(C),C
	LD	C,$5D
	OUT	(C),C

	EI
	NOP

	LD	IX,$C400
	LD	DE,InitHW
	LD	HL,Loop
	LD	C,8
	LD	B,20

DrawTile:
	rept 7
	LD	A,(DE)
	LD	(IX),A
	INC	DE

	LD	A,(HL)
	LD	(IX+1),A
	INC	HL

	LD	A,IXH
	ADD	C
	LD	IXH,A
	endm

	LD	A,(DE)
	LD	(IX),A
	INC	DE

	LD	A,IXL
	ADD	102
	LD	IXL,A
	LD	A,IXH
	ADC	$C8
	AND	$F7
	LD	IXH,A

	DJNZ	DrawTile

	JP	Loop

Interrupt:
	PUSH	BC
	LD	BC,$7F10
	OUT	(C),C
	LD	C,$48
	OUT	(C),C
	LD	B,14
ILoop:
	DJNZ	ILoop
	LD	BC,$7F4F
	OUT	(C),C
	POP	BC
	EI
	RET

EndDemo:
